## 说说include头文件的顺序以及双引号""和尖括号<>的区别
参考回答

区别：

（1）尖括号<>的头文件是系统文件，双引号""的头文件是自定义文件。

（2）编译器预处理阶段查找头文件的路径不一样。

查找路径：

（1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。

（2）使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

## 导入C函数的关键字是什么，C++编译时和C有什么不同？
关键字：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
```CPP
//extern示例 
//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 
extern "C" int strcmp(const char *s1, const char *s2);  //在C++程序里边声明该函数 
extern "C"{     #include <string.h>//string.h里边包含了要调用的C函数的声明 
}  
//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__
```

## 简述C++从代码到可执行二进制文件的过程
有四个过程，**预编译、编译、汇编、链接**

预编译：这个过程主要的处理操作如下：

（1） 将所有的#define删除，并且展开所有的宏定义

（2） 处理所有的条件预编译指令，如#if、#ifdef

（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

（4） 过滤所有的注释

（5） 添加行号和文件名标识。

编译：这个过程主要的处理操作如下：

（1） 词法分析：将源代码的字符序列分割成一系列的记号。

（2） 语法分析：对记号进行语法分析，产生语法树。

（3） 语义分析：判断表达式是否有意义。

（4） 代码优化：

（5） 目标代码生成：生成汇编代码。

（6） 目标代码优化：

汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

链接分为静态链接和动态链接。

静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

## 程序启动的过程：

操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。

加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。

加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数

初始化应用程序的全局变量，对于全局对象自动调用构造函数。

进入应用程序入口点函数开始执行。

## 一个程序有哪些section：
![mem_sections](../Picture/mem-sections.png)
如上图，从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等组成。

数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。

代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

可执行程序在运行时又会多出两个区域：堆区和栈区。

堆区：动态申请内存用。堆从低地址向高地址增长。

栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

最后还有一个共享区，位于堆和栈之间。