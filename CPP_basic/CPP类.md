## 1. 面向对象的三大特性：封装、继承、多态

C++调用C函数需要extern C，因为C语言没有函数重载。
子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。
多态 **基类指针指向子类对象，调用相应的虚函数**，可以根据指向的子类的不同而实现不同的方法

## 2、类的访问权限：private、protected、public
参考回答：C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员

在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。
另外，class还可以定义模板类形参，比如template <class T, int i>

## 3.类的构造函数、析构函数、赋值函数、拷贝函数


## 深拷贝 浅拷贝区别
C++拷贝构造只能传递饮用不能传值
调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

## 空类有哪些函数？空类的大小？
编译器会自动为你生成一个默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符、一个默认析构函数、取址运算符和一个取址运算符const。这些函数只有在第一次被调用时，才会别编译器创建。所有这些函数都是inline和public的。
```
class Empty
{
public:
Empty(); // 缺省构造函数//
Empty( const Empty& ); // 拷贝构造函数//
~Empty(); // 析构函数//
Empty& operator=( const Empty& ); // 赋值运算符//
Empty* operator&(); // 取址运算符
const Empty* operator&() const; // 取址运算符 const
};
```
在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。如果没有这一个字节的占位，那么空类就无所谓实例化了，因为实例化的过程就是在内存中分配一块地址。
注意：当该空白类作为基类时，该类的大小就优化为0了，这就是所谓的空白基类最优化。
注意：空白基类最优化无法被施加于多重继承上只适合单一继承。

## struct内存对齐
https://zhuanlan.zhihu.com/p/93822540
## 指针与引用的区别
1.指针有自己的一块空间，而引用只是一个别名；
2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
5.可以有const指针，但是没有const引用；
6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7.指针可以有多级指针（**p），而引用至于一级；
8.指针和引用使用++运算符的意义不一样；
9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。
# 指针和数组的区别
| 指针 | 数组 |
| ------ | ------ |
| 保存数据的地址间接访问数据 |保存数据|
| 首先获得指针的内容，然后将其作为地址，从该地址中提取数据通常用于动态的数据结构 | 直接访问数据|
|通过Malloc分配内存，free释放内存 |隐式的分配和删除|
| 通常指向匿名数据，操作匿名函数 | 自身即为数据名 |


## 多态：动态多态、静态多态
多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

## 静态多态：重写、重载、模板
重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写